{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///kendo-elasticsearch.min.js","webpack:///webpack/bootstrap 6c4041802c99665bb74a","webpack:///./src/kendo-elasticsearch.js","webpack:///./src/sort.js","webpack:///./src/groups.js","webpack:///./src/aggregations.js","webpack:///./src/es-utils.js","webpack:///./src/data-items.js","webpack:///./src/filters.js","webpack:///./src/fields.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","_sort","sort","_groups","groups","_aggregations","aggregations","_filters","filters","_esUtils","esUtils","_dataItems","dataItems","_fields","fields","data","kendo","ElasticSearchDataSource","DataSource","extend","init","initOptions","Error","transport","read","url","readTransport","dataType","method","contentType","_model","schema","model","esMapping","kendoFieldsFromESMapping","fill","_nestedFields","_subTypes","keys","forEach","fieldKey","field","esNestedPath","push","esName","esParentType","esChildType","parameterMap","sortParams","prepareParams","group","columns","esParams","skip","from","take","size","aggregationsOnly","kendo2es","query","filtered","filter","innerHits","esMappingKey","_source","k","map","aggs","aggregate","JSON","stringify","parse","response","items","fromHits","hits","doc_count","total","aggregates","es2kendo","grps","serverFiltering","serverSorting","serverPaging","serverAggregates","serverGrouping","fn","fromMapping","_defineProperty","value","defineProperty","enumerable","configurable","writable","_kendo2es","nestedPath","sortItem","esFilterName","order","dir","missing","mode","_prepareParams","sortArray","constructor","Array","fullSort","matchingSort","length","splice","indexOf","concat","nestedFields","previousLevelAggs","previousLevelNestedPath","nextLevelAggs","_kendoGroup2es","nested","path","esFullNestedPath","previousLevelAgg","aggKey","groupAgg","missingAgg","fieldAggregate","groupAggregates","type","esAggName","interval","terms","esGroupAggregates","_parseGroupAggregations","missingNested","groupAggregations","substr","_es2kendo","allGroups","groupAggregation","groupDefs","_esAgg2kendo","fillInGroups","hasSubgroups","buckets","bucketKey","bucket","missingAggregation","groupsMap","groupKeys","key_as_string","count","undefined","groupNestedPath","esAggs","aggItem","aggsWrapper","previousPathParts","group_reverse_nested","reverse_nested","split","nestedPathPart","currentPath","join","fullCurrentPath","currentFields","innerHitsFilter","kendoToESAgg","previousAggregates","aggType","suffixLength","min","max","sum","average","_innerHits","subTypes","previousLevelInnerHits","_innerHitsFilter","inner_hits","subType","$","logicFilter","or","and","childFilter","not","has_child","has_parent","_fillInGroups","dataItem","fieldValue","Date","i","groupDefValue","groupDefNextValue","_getValuesFromSource","source","pathParts","values","isArray","valueItem","slice","_fromHits","innerPath","hit","hitSource","_id","esNameSplit","duration","moment","startOf","diff","esMultiSplit","esMultiSeparator","splittedItems","innerHitKey","nestedItems","newSplittedDataItems","splittedItem","nestedItem","mergedItem","_splitMultiValues","results","item","itemResults","partialItemResults","val","result","newResult","k2","kendoFilters","logicalConnective","operator","logic","esFilters","esNestedFilters","esFilter","query_string","_filterParam","analyze_wildcard","esNestedFilter","kendoFilter","subtract","format","add","fieldName","esSearchName","fieldEscaped","_asESParameter","valueEscaped","simpleBinaryOperators","eq","search","lt","lte","gt","gte","esOperator","expression","toISOString","replace","match","escapeSearchValueRegexp","escapeValueRegexp","_fromMapping","mapping","prefix","esPrefix","properties","propertyKey","property","curedPropertyKey","asKendoPropertyKey","prefixedName","subNestedPath","index","esSearchSubField","esFilterSubField","esAggSubField","_fill","esStringSubFields","agg"],"mappings":"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","file":"kendo-elasticsearch.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"kendo-elasticsearch\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"kendo-elasticsearch\"] = factory();\n\telse\n\t\troot[\"kendo-elasticsearch\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"kendo-elasticsearch\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"kendo-elasticsearch\"] = factory();\n\telse\n\t\troot[\"kendo-elasticsearch\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _sort = __webpack_require__(1);\n\t\n\tvar sort = _interopRequireWildcard(_sort);\n\t\n\tvar _groups = __webpack_require__(2);\n\t\n\tvar groups = _interopRequireWildcard(_groups);\n\t\n\tvar _aggregations = __webpack_require__(3);\n\t\n\tvar aggregations = _interopRequireWildcard(_aggregations);\n\t\n\tvar _filters = __webpack_require__(6);\n\t\n\tvar filters = _interopRequireWildcard(_filters);\n\t\n\tvar _esUtils = __webpack_require__(4);\n\t\n\tvar esUtils = _interopRequireWildcard(_esUtils);\n\t\n\tvar _dataItems = __webpack_require__(5);\n\t\n\tvar dataItems = _interopRequireWildcard(_dataItems);\n\t\n\tvar _fields = __webpack_require__(7);\n\t\n\tvar fields = _interopRequireWildcard(_fields);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar data = kendo.data; /**\n\t                        * A Kendo DataSource that gets its data from ElasticSearch.\n\t                        *\n\t                        * Read-only, supports paging, filtering, sorting, grouping and aggregations.\n\t                        */\n\t\n\tdata.ElasticSearchDataSource = data.DataSource.extend({\n\t  init: function init(initOptions) {\n\t    if (!initOptions) {\n\t      throw new Error('Options are required to use ElasticSearchDataSource');\n\t    }\n\t\n\t    // Prepare the transport to query ES\n\t    // The only required parameter is transport.read.url\n\t    if (initOptions.transport && initOptions.transport.read && initOptions.transport.read.url) {\n\t      var readTransport = initOptions.transport.read;\n\t      readTransport.dataType = readTransport.dataType || 'json';\n\t      readTransport.method = readTransport.method || 'POST';\n\t      readTransport.contentType = readTransport.contentType || 'application/json';\n\t    } else {\n\t      throw new Error('transport.read.url must be set to use ElasticSearchDataSource');\n\t    }\n\t\n\t    var _model = initOptions.schema && initOptions.schema.model;\n\t    if (!_model) {\n\t      throw new Error('transport.schema.model must be set to use ElasticSearchDataSource');\n\t    }\n\t    if (_model.esMapping) {\n\t      _model.fields = _model.fields || {};\n\t      data.ElasticSearchDataSource.kendoFieldsFromESMapping(_model.esMapping, _model, _model.fields);\n\t    } else {\n\t      if (!_model.fields) {\n\t        throw new Error('transport.schema.model.fields/esMapping must be set');\n\t      }\n\t      fields.fill(_model.fields, _model);\n\t    }\n\t\n\t    // Get sets of nesting levels\n\t    var _nestedFields = {};\n\t    var _subTypes = {};\n\t    Object.keys(_model.fields).forEach(function (fieldKey) {\n\t      var field = _model.fields[fieldKey];\n\t      if (field.esNestedPath) {\n\t        _nestedFields[field.esNestedPath] = _nestedFields[field.esNestedPath] || [];\n\t        _nestedFields[field.esNestedPath].push(field.esName);\n\t      }\n\t      if (field.esParentType) {\n\t        _subTypes[field.esParentType] = _subTypes[field.esParentType] || [];\n\t        _subTypes[field.esParentType].push(field.esName);\n\t      }\n\t      if (field.esChildType) {\n\t        _subTypes[field.esChildType] = _subTypes[field.esChildType] || [];\n\t        _subTypes[field.esChildType].push(field.esName);\n\t      }\n\t    });\n\t\n\t    // Prepare the content of the query that will be sent to ES\n\t    // based on the kendo data structure\n\t    initOptions.transport.parameterMap = function (data) {\n\t      var sortParams = sort.prepareParams(data.sort, data.group, data.columns);\n\t\n\t      var esParams = {};\n\t      if (data.skip) {\n\t        esParams.from = data.skip;\n\t      }\n\t      if (data.take) {\n\t        esParams.size = data.take;\n\t      }\n\t\n\t      if (initOptions.aggregationsOnly) {\n\t        esParams.from = 0;\n\t        esParams.size = 0;\n\t      }\n\t\n\t      // Transform kendo sort params in a ES sort list\n\t      esParams.sort = sort.kendo2es(sortParams, _model.fields);\n\t\n\t      // Transform kendo filters into a ES query using a query_string request\n\t      esParams.query = {\n\t        filtered: {\n\t          filter: filters.kendo2es(data.filter || [], _model.fields)\n\t        }\n\t      };\n\t\n\t      // Add a top level inner_hits definition for nested/parent/child docs\n\t      esParams['inner_hits'] = esUtils.innerHits(_nestedFields, _model.esMappingKey, _subTypes, esParams.sort, esParams.query.filtered.filter);\n\t\n\t      // Fetch only the required list of fields from ES\n\t      esParams._source = Object.keys(_model.fields).filter(function (k) {\n\t        return !_model.fields[k].esNestedPath && !_model.fields[k].esParentType && !_model.fields[k].esChildType;\n\t      }).map(function (k) {\n\t        return _model.fields[k].esName;\n\t      });\n\t\n\t      // Transform kendo aggregations into ES aggregations\n\t      esParams.aggs = aggregations.kendo2es(data.aggregate, _model.fields, _nestedFields, _model.esMappingKey, esParams.query.filtered.filter);\n\t\n\t      // Transform Kendo group instruction into an ES bucket aggregation\n\t      groups.kendo2es(esParams.aggs, data.group, _model.fields, _nestedFields, _model.esMappingKey, esParams.query.filtered.filter);\n\t\n\t      return JSON.stringify(esParams);\n\t    };\n\t\n\t    var schema = initOptions.schema;\n\t\n\t    // Parse the results from elasticsearch to return data items,\n\t    // total and aggregates for Kendo grid\n\t    schema.parse = function (response) {\n\t      var items = dataItems.fromHits(response.hits.hits, _model.fields);\n\t\n\t      // cheat. Root aggregations used as a pseudo buckets with doc_count = total number of results\n\t      // used to process missing counts\n\t      if (response.aggregations) {\n\t        response.aggregations.doc_count = response.hits.total;\n\t      }\n\t      var aggregates = aggregations.es2kendo(response.aggregations);\n\t      var grps = groups.es2kendo(items, response.aggregations, _model.fields, initOptions.aggregationsOnly);\n\t\n\t      return {\n\t        total: response.hits.total,\n\t        data: items,\n\t        aggregates: aggregates,\n\t        groups: grps\n\t      };\n\t    };\n\t\n\t    schema.aggregates = function (response) {\n\t      return response.aggregates;\n\t    };\n\t    schema.groups = function (response) {\n\t      return response.groups;\n\t    };\n\t\n\t    schema.data = schema.data || 'data';\n\t    schema.total = schema.total || 'total';\n\t    schema.model.id = schema.model.id || '_id';\n\t\n\t    initOptions.serverFiltering = true;\n\t    initOptions.serverSorting = true;\n\t    initOptions.serverPaging = true;\n\t    initOptions.serverAggregates = true;\n\t    initOptions.serverGrouping = true;\n\t\n\t    data.DataSource.fn.init.call(this, initOptions);\n\t  }\n\t});\n\t\n\tdata.ElasticSearchDataSource.kendoFieldsFromESMapping = fields.fromMapping;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tvar kendo2es = exports.kendo2es = _kendo2es;\n\tvar prepareParams = exports.prepareParams = _prepareParams;\n\t\n\t// Transform sort instruction into some object suitable for Elasticsearch\n\t// Also deal with sorting the different nesting levels\n\tfunction _kendo2es(sort, fields, nestedPath) {\n\t  return sort.filter(function (sortItem) {\n\t    var field = fields[sortItem.field];\n\t    if (!field) return false;\n\t    return field.esNestedPath === nestedPath || field.esParentType === nestedPath || field.esChildType === nestedPath;\n\t  }).map(function (sortItem) {\n\t    return _defineProperty({}, fields[sortItem.field].esFilterName, {\n\t      order: sortItem.dir,\n\t      missing: '_last',\n\t      mode: sortItem.dir === 'asc' ? 'min' : 'max'\n\t    });\n\t  });\n\t};\n\t\n\t// Prepare sort parameters for easier transformation to ES later on\n\tfunction _prepareParams(sort, groups) {\n\t  // first fix the type of the param that can be object of group\n\t  var sortArray = [];\n\t  if (sort && sort.constructor === Array) {\n\t    sortArray = sort;\n\t  } else {\n\t    if (sort) {\n\t      sortArray.push(sort);\n\t    }\n\t  }\n\t\n\t  // Sort instructions for the groups are first\n\t  var fullSort = [];\n\t  (groups || []).forEach(function (group) {\n\t    var matchingSort = sortArray.filter(function (sortItem) {\n\t      return sortItem.field === group.field;\n\t    });\n\t    if (matchingSort.length) {\n\t      fullSort.push(matchingSort[0]);\n\t      sortArray.splice(sortArray.indexOf(matchingSort[0]), 1);\n\t    } else {\n\t      fullSort.push({\n\t        field: group.field,\n\t        dir: group.dir || 'asc'\n\t      });\n\t    }\n\t  });\n\t\n\t  // Then original sort instructions are added\n\t  fullSort = fullSort.concat(sortArray);\n\t\n\t  return fullSort;\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.es2kendo = exports.kendo2es = undefined;\n\t\n\tvar _aggregations = __webpack_require__(3);\n\t\n\tvar aggregations = _interopRequireWildcard(_aggregations);\n\t\n\tvar _dataItems = __webpack_require__(5);\n\t\n\tvar dataItems = _interopRequireWildcard(_dataItems);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar kendo2es = exports.kendo2es = _kendo2es;\n\tvar es2kendo = exports.es2kendo = _es2kendo;\n\t\n\t// Transform kendo groups declaration into ES bucket aggregations\n\tfunction _kendo2es(aggs, groups, fields, nestedFields, esMappingKey, filter) {\n\t  var previousLevelAggs = [aggs];\n\t  var previousLevelNestedPath = null;\n\t  groups.forEach(function (group) {\n\t    var field = fields[group.field];\n\t    var nextLevelAggs = _kendoGroup2es(group, fields, nestedFields, esMappingKey, filter);\n\t\n\t    var aggs = {};\n\t    if (field.esNestedPath && field.esNestedPath.indexOf(previousLevelNestedPath) !== 0) {\n\t      aggs[field.esNestedPath + '_nested'] = aggs[field.esNestedPath + '_nested'] || {\n\t        nested: {\n\t          path: field.esFullNestedPath\n\t        },\n\t        aggs: {}\n\t      };\n\t      aggs[field.esNestedPath + '_nested'].aggs[group.field + '_group'] = nextLevelAggs.group;\n\t      aggs[field.esNestedPath + '_nested'].aggs[group.field + '_missing'] = nextLevelAggs.missing;\n\t    } else {\n\t      aggs[group.field + '_group'] = nextLevelAggs.group;\n\t      aggs[group.field + '_missing'] = nextLevelAggs.missing;\n\t    } // 3rd case for nested path that is not child of the previous group\n\t\n\t    previousLevelAggs.forEach(function (previousLevelAgg) {\n\t      Object.keys(aggs).forEach(function (aggKey) {\n\t        previousLevelAgg[aggKey] = aggs[aggKey];\n\t      });\n\t    });\n\t    previousLevelAggs = Object.keys(nextLevelAggs).map(function (aggKey) {\n\t      return nextLevelAggs[aggKey].aggregations;\n\t    });\n\t    previousLevelNestedPath = field.esNestedPath;\n\t  });\n\t}\n\t\n\tfunction _kendoGroup2es(group, fields, nestedFields, esMappingKey, filter) {\n\t  var field = fields[group.field];\n\t  var groupAgg = {};\n\t  var missingAgg = {};\n\t\n\t  // Look for a aggregate defined on group field\n\t  // Used to customize the bucket aggregation for range, histograms, etc.\n\t  var fieldAggregate = void 0;\n\t  var groupAggregates = [];\n\t  (group.aggregates || []).forEach(function (aggregate) {\n\t    // We exclude strings that are not concerned by specific aggregations (only terms buckets)\n\t    // And cause bugs when counting cardinality on own group.\n\t    if (aggregate.field === group.field && field.type !== 'string') {\n\t      fieldAggregate = aggregate;\n\t    } else {\n\t      groupAggregates.push(aggregate);\n\t    }\n\t  });\n\t\n\t  if (fieldAggregate) {\n\t\n\t    // We support date histogramms if a 'interval' key is passed\n\t    // to the group definition\n\t    groupAgg[fieldAggregate.aggregate] = {\n\t      field: field.esAggName\n\t    };\n\t    if (fieldAggregate.interval) {\n\t      groupAgg[fieldAggregate.aggregate].interval = fieldAggregate.interval;\n\t    }\n\t  } else {\n\t\n\t    // Default is a term bucket aggregation\n\t    // if used on a not analyzed field or subfield\n\t    // it will create a group for each value of the field\n\t    groupAgg.terms = {\n\t      field: field.esAggName,\n\t      size: 0\n\t    };\n\t  }\n\t\n\t  missingAgg.missing = {\n\t    field: field.esAggName\n\t  };\n\t\n\t  var esGroupAggregates = aggregations.kendo2es(groupAggregates, fields, nestedFields, esMappingKey, filter, field.esNestedPath);\n\t  groupAgg.aggregations = esGroupAggregates;\n\t  missingAgg.aggregations = esGroupAggregates;\n\t\n\t  return {\n\t    group: groupAgg,\n\t    missing: missingAgg\n\t  };\n\t}\n\t\n\t// Extraction aggregations from ES query result that will be used to group\n\t// data items\n\tfunction _parseGroupAggregations(aggregations, missingNested) {\n\t  var groupAggregations = Object.keys(aggregations).filter(function (aggKey) {\n\t    return aggKey.substr(aggKey.length - 6) === '_group';\n\t  }).map(function (aggKey) {\n\t    var fieldKey = aggKey.substr(0, aggKey.length - 6);\n\t    if (missingNested) {\n\t      aggregations[fieldKey + '_missing'].doc_count += missingNested;\n\t    }\n\t    return {\n\t      group: aggregations[aggKey],\n\t      missing: aggregations[fieldKey + '_missing'],\n\t      fieldKey: fieldKey\n\t    };\n\t  });\n\t\n\t  // extract other group aggregations from nested aggregations\n\t  Object.keys(aggregations).filter(function (aggKey) {\n\t    return aggKey.substr(aggKey.length - 7) === '_nested';\n\t  }).forEach(function (aggKey) {\n\t    // 'missing' count on a nested group aggregation =\n\t    //      'document without nested objects' + 'nested objects with missing field'\n\t    // and 'document without nested objects' is equal to 'number of documents' - 'number of nested documents'\n\t    var missingNested = aggregations.doc_count - aggregations[aggKey].doc_count;\n\t    groupAggregations = groupAggregations.concat(_parseGroupAggregations(aggregations[aggKey], missingNested));\n\t  });\n\t\n\t  return groupAggregations;\n\t}\n\t\n\t// Transform ES bucket aggregations into kendo groups of data items\n\t// See doc here for format of groups:\n\t// http://docs.telerik.com/KENDO-UI/api/javascript/data/datasource#configuration-schema.groups\n\tfunction _es2kendo(items, aggregations, fields, aggregationsOnly) {\n\t  var allGroups = [];\n\t  if (aggregations) {\n\t    var groupAggregations = _parseGroupAggregations(aggregations);\n\t\n\t    // Find aggregations that are grouping aggregations (ie buckets in ES)\n\t    groupAggregations.forEach(function (groupAggregation) {\n\t      var groups = [];\n\t\n\t      var groupDefs = _esAgg2kendo(groupAggregation.group, groupAggregation.missing, groupAggregation.fieldKey);\n\t\n\t      if (!aggregationsOnly) {\n\t        // Then distribute the data items in the groups\n\t        groups = dataItems.fillInGroups(groupDefs, items, fields[groupAggregation.fieldKey]);\n\t      } else {\n\t        groups = groupDefs.keys.map(function (key) {\n\t          return groupDefs.map[key];\n\t        });\n\t      }\n\t\n\t      // Case when there is subgroups. Solve it recursively.\n\t      var hasSubgroups = false;\n\t      if (groupAggregation.group.buckets && groupAggregation.group.buckets[0]) {\n\t        Object.keys(groupAggregation.group.buckets[0]).forEach(function (bucketKey) {\n\t          if (bucketKey.substr(bucketKey.length - 6) === '_group' || bucketKey.substr(bucketKey.length - 7) === '_nested') {\n\t            hasSubgroups = true;\n\t          }\n\t        });\n\t      }\n\t      groups.forEach(function (group) {\n\t        if (hasSubgroups) {\n\t          group.hasSubgroups = true;\n\t          group.items = _es2kendo(group.items, group.bucket, fields, aggregationsOnly);\n\t        }\n\t        delete group.bucket;\n\t      });\n\t\n\t      allGroups = allGroups.concat(groups);\n\t    });\n\t  }\n\t\n\t  return allGroups;\n\t}\n\t\n\t// Transform a single bucket aggregation into kendo groups definitions\n\t// Does not fill up the data items\n\tfunction _esAgg2kendo(groupAggregation, missingAggregation, fieldKey) {\n\t  var groupsMap = {};\n\t  var groupKeys = [];\n\t\n\t  // Each bucket in ES aggregation result is a group\n\t  groupAggregation.buckets.forEach(function (bucket) {\n\t    var bucketKey = bucket.key_as_string || bucket.key;\n\t    groupKeys.push(bucketKey);\n\t    groupsMap[bucketKey] = {\n\t      field: fieldKey,\n\t      value: bucketKey,\n\t      hasSubgroups: false,\n\t      aggregates: aggregations.es2kendo(bucket),\n\t      items: [],\n\t      bucket: bucket\n\t    };\n\t    groupsMap[bucketKey].aggregates[fieldKey] = {\n\t      count: bucket.doc_count\n\t    };\n\t  });\n\t\n\t  // Special case for the missing value\n\t  groupsMap[''] = {\n\t    field: fieldKey,\n\t    value: '',\n\t    hasSubgroups: false,\n\t    aggregates: aggregations.es2kendo(missingAggregation),\n\t    items: [],\n\t    bucket: missingAggregation\n\t  };\n\t  groupsMap[''].aggregates[fieldKey] = {\n\t    count: missingAggregation.doc_count\n\t  };\n\t\n\t  return {\n\t    map: groupsMap,\n\t    keys: groupKeys\n\t  };\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.es2kendo = exports.kendo2es = undefined;\n\t\n\tvar _esUtils = __webpack_require__(4);\n\t\n\tvar esUtils = _interopRequireWildcard(_esUtils);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar kendo2es = exports.kendo2es = _kendo2es;\n\tvar es2kendo = exports.es2kendo = _es2kendo;\n\t\n\tvar kendoToESAgg = {\n\t  count: 'cardinality',\n\t  min: 'min',\n\t  max: 'max',\n\t  sum: 'sum',\n\t  average: 'avg'\n\t};\n\t\n\t// Transform kendo aggregates into ES metric aggregations\n\tfunction _kendo2es(aggregate, fields, nestedFields, esMappingKey, filter, groupNestedPath) {\n\t  var esAggs = {};\n\t\n\t  (aggregate || []).forEach(function (aggItem) {\n\t    var field = fields[aggItem.field];\n\t    var nestedPath = field.esNestedPath;\n\t    var aggsWrapper = esAggs;\n\t    if (groupNestedPath !== nestedPath) {\n\t      (function () {\n\t        var previousPathParts = [];\n\t        if (groupNestedPath && nestedPath.indexOf(groupNestedPath) !== 0) {\n\t          esAggs.group_reverse_nested = esAggs.group_reverse_nested || {\n\t            reverse_nested: {},\n\t            aggregations: {}\n\t          };\n\t          aggsWrapper = esAggs.group_reverse_nested.aggregations;\n\t        } else if (groupNestedPath) {\n\t          nestedPath = nestedPath.substr(groupNestedPath.length + 1, nestedPath.length);\n\t        }\n\t\n\t        nestedPath.split('.').forEach(function (nestedPathPart) {\n\t          previousPathParts.push(nestedPathPart);\n\t          var currentPath = groupNestedPath ? groupNestedPath + '.' + previousPathParts.join('.') : previousPathParts.join('.');\n\t          var fullCurrentPath = esMappingKey ? esMappingKey + '.' + currentPath : currentPath;\n\t          var currentFields = nestedFields[currentPath];\n\t          if (!currentFields) return;\n\t          if (!aggsWrapper[currentPath]) {\n\t            aggsWrapper[currentPath + '_filter_nested'] = aggsWrapper[currentPath + '_filter_nested'] || {\n\t              nested: {\n\t                path: fullCurrentPath\n\t              },\n\t              aggregations: {}\n\t            };\n\t            aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'] = aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'] || {\n\t              filter: esUtils.innerHitsFilter(fullCurrentPath, null, filter),\n\t              aggregations: {}\n\t            };\n\t          }\n\t          aggsWrapper = aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'].aggregations;\n\t        });\n\t      })();\n\t    }\n\t\n\t    aggsWrapper[aggItem.field + '_' + aggItem.aggregate] = {};\n\t    aggsWrapper[aggItem.field + '_' + aggItem.aggregate][kendoToESAgg[aggItem.aggregate]] = {\n\t      field: field.esAggName\n\t    };\n\t  });\n\t\n\t  return esAggs;\n\t}\n\t\n\t// Transform aggregation results from a ES query to kendo aggregates\n\tfunction _es2kendo(aggregations, previousAggregates) {\n\t  var aggregates = previousAggregates || {};\n\t  aggregations = aggregations || {};\n\t  Object.keys(aggregations).forEach(function (aggKey) {\n\t    if (!aggregations[aggKey]) return;\n\t    ['count', 'min', 'max', 'average', 'sum'].forEach(function (aggType) {\n\t      var suffixLength = aggType.length + 1;\n\t      if (aggKey.substr(aggKey.length - suffixLength) === '_' + aggType) {\n\t        var fieldKey = aggKey.substr(0, aggKey.length - suffixLength);\n\t        aggregates[fieldKey] = aggregates[fieldKey] || {};\n\t        aggregates[fieldKey][aggType] = aggregations[aggKey].value;\n\t      }\n\t    });\n\t\n\t    if (aggKey.substr(aggKey.length - 7) === '_nested' || aggKey.substr(aggKey.length - 7) === '_filter') {\n\t      // recursivity on intermediate levels\n\t      _es2kendo(aggregations[aggKey], aggregates);\n\t    }\n\t  });\n\t  return aggregates;\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t// Some function that work on ES queries to deal with nested levels and other\n\t// difficulties\n\t\n\tvar innerHits = exports.innerHits = _innerHits;\n\tvar innerHitsFilter = exports.innerHitsFilter = _innerHitsFilter;\n\t\n\t// Get a root inner_hits definition to fetch all nested/parent/child docs\n\tfunction _innerHits(nestedFields, esMappingKey, subTypes, sort, filter) {\n\t  var innerHits = {};\n\t  Object.keys(nestedFields).forEach(function (nestedPath) {\n\t    var previousLevelInnerHits = innerHits;\n\t    var previousPathParts = [];\n\t    nestedPath.split('.').forEach(function (nestedPathPart) {\n\t      previousPathParts.push(nestedPathPart);\n\t      var currentPath = previousPathParts.join('.');\n\t      var fullCurrentPath = esMappingKey ? esMappingKey + '.' + currentPath : currentPath;\n\t      var currentFields = nestedFields[currentPath];\n\t      if (!currentFields) {\n\t        return;\n\t      }\n\t      if (!previousLevelInnerHits[currentPath]) {\n\t        previousLevelInnerHits[currentPath] = {\n\t          path: _defineProperty({}, fullCurrentPath, {\n\t            _source: currentFields,\n\t            size: 10000,\n\t            sort: sort,\n\t            query: {\n\t              filtered: {\n\t                filter: _innerHitsFilter(fullCurrentPath, null, filter)\n\t              }\n\t            }\n\t          })\n\t        };\n\t      }\n\t      if (currentPath !== nestedPath) {\n\t        previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits = previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits || {};\n\t        previousLevelInnerHits = previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits;\n\t      }\n\t    });\n\t  });\n\t\n\t  Object.keys(subTypes).forEach(function (subType) {\n\t    var currentFields = subTypes[subType];\n\t    innerHits[subType] = {\n\t      type: _defineProperty({}, subType, {\n\t        _source: currentFields,\n\t        size: 10000,\n\t        sort: sort,\n\t        query: {\n\t          filtered: {\n\t            filter: _innerHitsFilter(null, subType, filter)\n\t          }\n\t        }\n\t      })\n\t    };\n\t  });\n\t  return innerHits;\n\t}\n\t\n\t// Traverse the filter to keep only the parts that concern\n\t// a nesting path\n\tfunction _innerHitsFilter(nestedPath, subType, filter) {\n\t  filter = $.extend(true, {}, filter);\n\t  var logicFilter = filter.or || filter.and;\n\t  if (logicFilter) {\n\t    logicFilter.filters = logicFilter.filters.filter(function (childFilter) {\n\t      return childFilter.and || childFilter.or || childFilter.nested && childFilter.nested.path === nestedPath || childFilter.not && childFilter.not.nested && childFilter.not.nested.path === nestedPath || childFilter.has_child && childFilter.has_child.type === subType || childFilter.not && childFilter.not.has_child && childFilter.not.has_child.type === subType || childFilter.has_parent && childFilter.has_parent.type === subType || childFilter.not && childFilter.not.has_parent && childFilter.not.has_parent.type === subType;\n\t    }).map(function (childFilter) {\n\t      if (childFilter.nested) {\n\t        return childFilter.nested.filter;\n\t      } else if (childFilter.not && childFilter.not.nested) {\n\t        return {\n\t          not: childFilter.not.nested.filter\n\t        };\n\t      } else if (childFilter.has_child) {\n\t        return childFilter.has_child.filter;\n\t      } else if (childFilter.not && childFilter.not.has_child) {\n\t        return {\n\t          not: childFilter.not.has_child.filter\n\t        };\n\t      } else if (childFilter.has_parent) {\n\t        return childFilter.has_parent.filter;\n\t      } else if (childFilter.not && childFilter.not.has_parent) {\n\t        return {\n\t          not: childFilter.not.has_parent.filter\n\t        };\n\t      } else {\n\t        return _innerHitsFilter(nestedPath, childFilter);\n\t      }\n\t    });\n\t  }\n\t  return filter;\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar fillInGroups = exports.fillInGroups = _fillInGroups;\n\tvar fromHits = exports.fromHits = _fromHits;\n\t\n\t// distribute data items in groups based on a field value\n\tfunction _fillInGroups(groupDefs, dataItems, field) {\n\t  var groups = [];\n\t  dataItems.forEach(function (dataItem) {\n\t    var group = groupDefs.map[dataItem[field.key] || ''];\n\t\n\t    // If no exact match, then we may be in some range aggregation ?\n\t    if (!group) {\n\t      var fieldValue = field.type === 'date' ? new Date(dataItem[field.key]) : dataItem[field.key];\n\t\n\t      for (var i = 0; i < groupDefs.keys.length; i++) {\n\t        var groupDefValue = field.type === 'date' ? new Date(groupDefs.keys[i]) : groupDefs.keys[i];\n\t        if (fieldValue >= groupDefValue) {\n\t          var groupDefNextValue = groupDefs.keys[i + 1] && (field.type === 'date' ? new Date(groupDefs.keys[i + 1]) : groupDefs.keys[i + 1]);\n\t          if (!groupDefNextValue || fieldValue < groupDefNextValue) {\n\t            group = groupDefs.map[groupDefs.keys[i]];\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    if (!group) {\n\t      throw new Error('No group found, val: ' + dataItem[field.key] + ' field: ' + field.key);\n\t    }\n\t    group.items.push(dataItem);\n\t    if (group.items.length === 1) {\n\t      groups.push(group);\n\t    }\n\t  });\n\t  return groups;\n\t}\n\t\n\t// Mimic fetching values from _source as the 'fields' functionality\n\t// would have done it.\n\t// We do not use the native 'fields' due to this bug:\n\t// https://github.com/elastic/elasticsearch/issues/14475\n\tfunction _getValuesFromSource(source, pathParts) {\n\t  var values = [];\n\t  var value = source[pathParts[0]];\n\t  if (value === undefined) {\n\t    return [];\n\t  }\n\t\n\t  if (pathParts.length > 1) {\n\t\n\t    // recursivity is not over, there remain some path parts\n\t    if ($.isArray(value)) {\n\t      value.forEach(function (valueItem) {\n\t        values = values.concat(_getValuesFromSource(valueItem, pathParts.slice(1)));\n\t      });\n\t    } else {\n\t      values = _getValuesFromSource(value, pathParts.slice(1));\n\t    }\n\t  } else {\n\t\n\t    // recursivity, we should be in a leaf value\n\t    if ($.isArray(value)) {\n\t      values = value;\n\t    } else {\n\t      values = [value];\n\t    }\n\t  }\n\t  return values;\n\t}\n\t\n\t// Transform hits from the ES query in to data items for kendo grid\n\t// The difficulty is that hits can contain inner hits and that some\n\t// fields can be multi-valued\n\tfunction _fromHits(hits, fields, innerPath) {\n\t\n\t  var dataItems = [];\n\t  hits.forEach(function (hit) {\n\t    var hitSource = hit._source || {};\n\t    var dataItem = {};\n\t\n\t    dataItem.id = [hit._id];\n\t    Object.keys(fields).filter(function (fieldKey) {\n\t      var field = fields[fieldKey];\n\t\n\t      // Keep only the fields that are part of this nested/parent/child\n\t      if (innerPath === undefined) {\n\t        return !(field.esNestedPath || field.esChildType || field.esParentType);\n\t      } else {\n\t        return field.esNestedPath === innerPath || field.esChildType === innerPath || field.esParentType === innerPath;\n\t      }\n\t    }).forEach(function (fieldKey) {\n\t      var field = fields[fieldKey];\n\t      var values = _getValuesFromSource(hitSource, field.esNameSplit);\n\t\n\t      // special case field that is a date deep down by displayed as a number\n\t      if (field.duration) {\n\t        if (!moment) {\n\t          throw new Error('Working on durations requires to load momentjs library');\n\t        }\n\t      }\n\t\n\t      if (field.duration === 'beforeToday') {\n\t        values = values.map(function (value) {\n\t          return moment().startOf('day').diff(moment(value).startOf('day'), 'days');\n\t        });\n\t      }\n\t\n\t      if (field.duration === 'afterToday') {\n\t        values = values.map(function (value) {\n\t          return moment(value).startOf('day').diff(moment().startOf('day'), 'days');\n\t        });\n\t      }\n\t\n\t      if (values) {\n\t        if (field.esMultiSplit) {\n\t          if (values && values.length) {\n\t            dataItem[fieldKey] = values;\n\t          } else {\n\t            dataItem[fieldKey] = [null];\n\t          }\n\t        } else {\n\t          dataItem[fieldKey] = values.join(field.esMultiSeparator || '\\n');\n\t        }\n\t      }\n\t    });\n\t\n\t    // Multiply and fill items based on nesting levels\n\t    var splittedItems = [dataItem];\n\t    Object.keys(hit.inner_hits || {}).forEach(function (innerHitKey) {\n\t      var nestedItems = _fromHits(hit.inner_hits[innerHitKey].hits.hits, fields, innerHitKey);\n\t      var newSplittedDataItems = [];\n\t      splittedItems.forEach(function (splittedItem) {\n\t        if (nestedItems.length) {\n\t          nestedItems.forEach(function (nestedItem) {\n\t            var mergedItem = {};\n\t            Object.keys(nestedItem).forEach(function (key) {\n\t              mergedItem[key] = nestedItem[key];\n\t            });\n\t            Object.keys(splittedItem).forEach(function (key) {\n\t              mergedItem[key] = splittedItem[key];\n\t            });\n\t            newSplittedDataItems.push(mergedItem);\n\t          });\n\t        } else {\n\t          newSplittedDataItems.push(splittedItem);\n\t        }\n\t      });\n\t      splittedItems = newSplittedDataItems;\n\t    });\n\t\n\t    dataItems = dataItems.concat(splittedItems);\n\t  });\n\t  return _splitMultiValues(dataItems);\n\t}\n\t\n\t// Split lines of data items based on their optionally multipl items\n\t// Example: [{a:[1,2],b:[3]}] -> [{a:1,b:3},{a:2,b:3}]\n\tfunction _splitMultiValues(items) {\n\t  var results = [];\n\t\n\t  // Iterates on items in the array and multiply based on multiple values\n\t  items.forEach(function (item) {\n\t    var itemResults = [{}];\n\t\n\t    // Iterate on properties of item\n\t    Object.keys(item).forEach(function (k) {\n\t      var partialItemResults = [];\n\t\n\t      // Iterate on the multiple values of this property\n\t      if (item[k] && item[k].constructor === Array) {\n\t        item[k].forEach(function (val) {\n\t          itemResults.forEach(function (result) {\n\t\n\t            // Clone the result to create variants with the different values of current key\n\t            var newResult = {};\n\t            Object.keys(result).forEach(function (k2) {\n\t              return newResult[k2] = result[k2];\n\t            });\n\t            newResult[k] = val;\n\t            partialItemResults.push(newResult);\n\t          });\n\t        });\n\t      } else {\n\t        itemResults.forEach(function (result) {\n\t          result[k] = item[k];\n\t          partialItemResults.push(result);\n\t        });\n\t      }\n\t      itemResults = partialItemResults;\n\t    });\n\t\n\t    results = results.concat(itemResults);\n\t  });\n\t  return results;\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar kendo2es = exports.kendo2es = _kendo2es;\n\t\n\t// Transform a tree of kendo filters into a tree of ElasticSearch filters\n\tfunction _kendo2es(kendoFilters, fields) {\n\t  var filters = void 0;\n\t\n\t  // logicalConnective can be \"and\" or \"or\"\n\t  var logicalConnective = 'and';\n\t\n\t  if (kendoFilters.operator) {\n\t    filters = [kendoFilters];\n\t  } else if (kendoFilters.logic) {\n\t    logicalConnective = kendoFilters.logic;\n\t    filters = kendoFilters.filters || [];\n\t  } else if (kendoFilters.constructor === Array) {\n\t    filters = kendoFilters;\n\t  } else {\n\t    throw new Error('Unsupported filter object: ' + kendoFilters);\n\t  }\n\t\n\t  var esFilters = [];\n\t  var esNestedFilters = {};\n\t\n\t  filters.forEach(function (filter) {\n\t    if (filter.logic) {\n\t      esFilters.push(_kendo2es(filter, fields));\n\t    } else {\n\t      var field = fields[filter.field];\n\t      if (!field) {\n\t        throw new Error('Unknown field in filter: ' + filter.field);\n\t      }\n\t      var esFilter = {\n\t        query: {\n\t          query_string: {\n\t            query: _filterParam(filter, fields),\n\t            // support uppercase/lowercase and accents\n\t            analyze_wildcard: true\n\t          }\n\t        }\n\t      };\n\t      if (field.esNestedPath) {\n\t        var esNestedFilter = esNestedFilters[field.esNestedPath] || {\n\t          nested: {\n\t            path: field.esFullNestedPath,\n\t            filter: {}\n\t          }\n\t        };\n\t        esNestedFilter.nested.filter[logicalConnective] = esNestedFilter.nested.filter[logicalConnective] || {\n\t          filters: []\n\t        };\n\t        esNestedFilter.nested.filter[logicalConnective].filters.push(esFilter);\n\t        if (!esNestedFilters[field.esNestedPath]) {\n\t          esFilter = esNestedFilters[field.esNestedPath] = esNestedFilter;\n\t        } else {\n\t          esFilter = null;\n\t        }\n\t      } else if (field.esParentType) {\n\t        esFilter = {\n\t          has_parent: {\n\t            type: field.esParentType,\n\t            filter: esFilter\n\t          }\n\t        };\n\t      } else if (field.esChildType) {\n\t        esFilter = {\n\t          has_child: {\n\t            type: field.esChildType,\n\t            filter: esFilter\n\t          }\n\t        };\n\t      }\n\t\n\t      if (esFilter) {\n\t        esFilters.push(esFilter);\n\t      }\n\t    }\n\t  });\n\t\n\t  var result = {};\n\t  result[logicalConnective] = {\n\t    filters: esFilters\n\t  };\n\t  return result;\n\t}\n\t\n\t// Transform a single kendo filter in a string\n\t// that can be used to compose a ES query_string query\n\tfunction _filterParam(kendoFilter, fields) {\n\t\n\t  // Boolean filter seems to forget the operator sometimes\n\t  kendoFilter.operator = kendoFilter.operator || 'eq';\n\t\n\t  // Use the filter field name except for contains\n\t  // that should use classical search instead of regexp\n\t  var field = fields[kendoFilter.field];\n\t\n\t  // special case field that is a date deep down by displayed as a number\n\t  if (field.duration) {\n\t    if (!moment) {\n\t      throw new Error('Working on durations requires to load momentjs library');\n\t    }\n\t  }\n\t\n\t  if (field.duration === 'beforeToday') {\n\t    kendoFilter.value = moment().startOf('day').subtract(kendoFilter.value, 'days').format();\n\t    if (kendoFilter.operator === 'lt') kendoFilter.operator = 'gt';else if (kendoFilter.operator === 'lte') kendoFilter.operator = 'gte';else if (kendoFilter.operator === 'gt') kendoFilter.operator = 'lt';else if (kendoFilter.operator === 'gte') kendoFilter.operator = 'lte';\n\t  }\n\t\n\t  if (field.duration === 'afterToday') {\n\t    kendoFilter.value = moment().startOf('day').add(kendoFilter.value, 'days').format();\n\t  }\n\t\n\t  var fieldName = void 0;\n\t  if (kendoFilter.operator === 'search') {\n\t    fieldName = field.esSearchName;\n\t  } else {\n\t    fieldName = field.esFilterName;\n\t  }\n\t\n\t  var fieldEscaped = _asESParameter(fieldName);\n\t  var valueEscaped = _asESParameter(kendoFilter.value, kendoFilter.operator);\n\t\n\t  var simpleBinaryOperators = {\n\t    eq: '',\n\t    search: '',\n\t    lt: '<',\n\t    lte: '<=',\n\t    gt: '>',\n\t    gte: '>='\n\t  };\n\t\n\t  if (simpleBinaryOperators[kendoFilter.operator] !== void 0) {\n\t    var esOperator = simpleBinaryOperators[kendoFilter.operator];\n\t    return fieldEscaped + ':' + esOperator + valueEscaped;\n\t  } else {\n\t    var expression = void 0;\n\t    switch (kendoFilter.operator) {\n\t      case 'neq':\n\t        return 'NOT (' + fieldEscaped + ':' + valueEscaped + ')';\n\t      case 'contains':\n\t        return '(' + fieldEscaped + ':*' + valueEscaped + '*)';\n\t      case 'doesnotcontain':\n\t        return 'NOT (' + fieldEscaped + ':*' + valueEscaped + '*)';\n\t      case 'startswith':\n\t        return fieldEscaped + ':' + valueEscaped + '*';\n\t      case 'endswith':\n\t        return fieldEscaped + ':*' + valueEscaped;\n\t      case 'missing':\n\t        if (field.esNestedPath || field.esParentType || field.esChildType) {\n\t          // missing in a nested document should be implemented as a \"not nested exists\"\n\t          // but this is not really doable when mixing with other filters\n\t          // see https://github.com/elastic/elasticsearch/issues/3495\n\t          throw new Error('missing filter is not supported on nested fields');\n\t        }\n\t        expression = '_missing_:' + fieldEscaped;\n\t        if (field.type === 'string') {\n\t          expression += ' OR (' + fieldEscaped + ':\"\")';\n\t        }\n\t        return expression;\n\t      case 'exists':\n\t        expression = '_exists_:' + fieldEscaped;\n\t        if (field.type === 'string') {\n\t          expression += ' AND NOT(' + fieldEscaped + ':\"\")';\n\t        }\n\t        return expression;\n\t      default:\n\t        throw new Error('Unsupported Kendo filter operator: ' + kendoFilter.operator);\n\t    }\n\t  }\n\t}\n\t\n\t// Escape values so that they are suitable as an elasticsearch query_string query parameter\n\tvar escapeValueRegexp = /[+\\-&|!()\\{}\\[\\]^:\"~*?:\\/ ]/g;\n\tvar escapeSearchValueRegexp = /[+\\-&|!()\\{}\\[\\]^:~:\\/]/g;\n\t\n\tfunction _asESParameter(value, operator) {\n\t  if (value.constructor === Date) {\n\t    value = value.toISOString();\n\t  } else if (typeof value === 'boolean' || typeof value === 'number') {\n\t    value = '' + value;\n\t  }\n\t\n\t  // For the special 'search' operator we allow some wildcard and other characters\n\t  if (operator === 'search') {\n\t    value = value.replace('\\\\', '\\\\\\\\');\n\t    if ((value.match(/\"/g) || []).length % 2 === 1) {\n\t      value = value.replace(/\"/g, '\\\\\"');\n\t    }\n\t    value = value.replace(escapeSearchValueRegexp, '\\\\$&');\n\t    return value;\n\t  }\n\t  return value.replace('\\\\', '\\\\\\\\').replace(escapeValueRegexp, '\\\\$&');\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar fromMapping = exports.fromMapping = _fromMapping;\n\tvar fill = exports.fill = _fill;\n\t\n\t// Transform a mapping definition from ElasticSearch into a kendo fields map\n\t// This utility function is exposed as it can be interesting to use it before instantiating\n\t// the actual datasource\n\t// @param mapping - An elasticsearch mapping\n\tfunction _fromMapping(mapping, model, fields, prefix, esPrefix, nestedPath) {\n\t  fields = fields || {};\n\t  prefix = prefix || '';\n\t  Object.keys(mapping.properties || {}).forEach(function (propertyKey) {\n\t    var property = mapping.properties[propertyKey];\n\t    var curedPropertyKey = asKendoPropertyKey(propertyKey);\n\t    var prefixedName = prefix ? prefix + '_' + curedPropertyKey : curedPropertyKey;\n\t    var esName = esPrefix ? esPrefix + '.' + propertyKey : propertyKey;\n\t\n\t    if (property.type === 'nested') {\n\t      // Case where the property is a nested object\n\t      var subNestedPath = nestedPath ? nestedPath + '.' + esName : esName;\n\t      _fromMapping(property, model, fields, prefixedName, '', subNestedPath);\n\t    } else if (property.properties) {\n\t      // Case where the property is a non nested object with properties\n\t      _fromMapping(property, model, fields, prefixedName, esName, nestedPath);\n\t    } else if (property.type === 'object') {\n\t      // Case where the property is a non nested object with zero subproperties. do nothing.\n\t    } else {\n\t      // Finally case of a leaf property\n\t      var field = fields[prefixedName] = fields[prefixedName] || {};\n\t\n\t      // if the field was already defined with a nested path,\n\t      // then we are in the case of field both nested and included in parent\n\t      // then we should not consider it as a real leaf property\n\t      if (!field.esNestedPath) {\n\t        field.type = field.type || property.type;\n\t\n\t        // ES supports a variety of numeric types. In JSON and kendo it is simply 'number'.\n\t        if (['float', 'double', 'integer', 'long', 'short', 'byte'].indexOf(field.type) !== -1) {\n\t          field.type = 'number';\n\t        }\n\t\n\t        // Default is splitting data lines except for string fields\n\t        if (field.type !== 'string') {\n\t          field.esMultiSplit = true;\n\t        }\n\t\n\t        if (nestedPath) {\n\t          field.esNestedPath = nestedPath;\n\t        }\n\t        field.esName = esName;\n\t\n\t        // When the field is not analyzed, the default string subfields should not be applied.\n\t        if (property.index === 'not_analyzed') {\n\t          field.esSearchSubField = null;\n\t          field.esFilterSubField = null;\n\t          field.esAggSubField = null;\n\t        }\n\t      }\n\t    }\n\t  });\n\t\n\t  _fill(fields, model);\n\t\n\t  return fields;\n\t};\n\t\n\t// Associate Kendo field names to ElasticSearch field names.\n\t// We have to allow ElasticSearch field names to be different\n\t// because ES likes an \"@\" and/or dots in field names while Kendo fails on that.\n\t// Filtering and aggregating can be based on a a different field if esFilterName\n\t// or esAggName are defined or on a subfield if esFilterSubField or esAggSubField are defined.\n\t// Typical use case is the main field is analyzed, but it has a subfield that is not\n\t// (or only with a minimal analyzer)\n\tfunction _fill(fields, model) {\n\t  for (var k in fields) {\n\t    if (fields.hasOwnProperty(k)) {\n\t      var field = fields[k];\n\t      field.key = k;\n\t      field.esName = field.esName || k;\n\t      field.esNameSplit = field.esName.split('.');\n\t      field.esFullNestedPath = field.esNestedPath;\n\t      if (model.esMappingKey) {\n\t        field.esFullNestedPath = model.esMappingKey + '.' + field.esFullNestedPath;\n\t      }\n\t      if (!field.esSearchName) {\n\t        field.esSearchName = field.esName;\n\t        if (field.hasOwnProperty('esSearchSubField')) {\n\t          if (field.esSearchSubField) {\n\t            field.esSearchName += '.' + field.esSearchSubField;\n\t          }\n\t        } else if (field.type === 'string' && model.esStringSubFields && model.esStringSubFields.search) {\n\t          field.esSearchName += '.' + model.esStringSubFields.search;\n\t        }\n\t        if (field.esNestedPath) {\n\t          field.esSearchName = field.esNestedPath + '.' + field.esSearchName;\n\t        }\n\t      }\n\t      if (!field.esFilterName) {\n\t        field.esFilterName = field.esName;\n\t        if (field.hasOwnProperty('esFilterSubField')) {\n\t          if (field.esFilterSubField) {\n\t            field.esFilterName += '.' + field.esFilterSubField;\n\t          }\n\t        } else if (field.type === 'string' && model.esStringSubFields && model.esStringSubFields.filter) {\n\t          field.esFilterName += '.' + model.esStringSubFields.filter;\n\t        }\n\t        if (field.esNestedPath) {\n\t          field.esFilterName = field.esNestedPath + '.' + field.esFilterName;\n\t        }\n\t      }\n\t      if (!field.esAggName) {\n\t        field.esAggName = field.esName;\n\t        if (field.hasOwnProperty('esAggSubField')) {\n\t          if (field.esAggSubField) {\n\t            field.esAggName += '.' + field.esAggSubField;\n\t          }\n\t        } else if (field.type === 'string' && model.esStringSubFields && model.esStringSubFields.agg) {\n\t          field.esAggName += '.' + model.esStringSubFields.agg;\n\t        }\n\t        if (field.esNestedPath) {\n\t          field.esAggName = field.esFullNestedPath + '.' + field.esAggName;\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t// Get a property key and transform it in a suitable key for kendo\n\t// the constraint is that kendo needs a key suitable for javascript object's dot notation\n\t// i.e a valid js identifier with alphanumeric chars + '_' and '$'\n\tfunction asKendoPropertyKey(value) {\n\t  return value.replace(/[^a-zA-z0-9_$]/g, '_');\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** kendo-elasticsearch.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6c4041802c99665bb74a\n **/","/**\n * A Kendo DataSource that gets its data from ElasticSearch.\n *\n * Read-only, supports paging, filtering, sorting, grouping and aggregations.\n */\n\nimport * as sort from './sort';\nimport * as groups from './groups';\nimport * as aggregations from './aggregations';\nimport * as filters from './filters';\nimport * as esUtils from './es-utils';\nimport * as dataItems from './data-items';\nimport * as fields from './fields';\n\nconst data = kendo.data;\n\ndata.ElasticSearchDataSource = data.DataSource.extend({\n  init(initOptions) {\n    if (!initOptions) {\n      throw new Error('Options are required to use ElasticSearchDataSource');\n    }\n\n    // Prepare the transport to query ES\n    // The only required parameter is transport.read.url\n    if (initOptions.transport && initOptions.transport.read && initOptions.transport.read.url) {\n      const readTransport = initOptions.transport.read;\n      readTransport.dataType = readTransport.dataType || 'json';\n      readTransport.method = readTransport.method || 'POST';\n      readTransport.contentType = readTransport.contentType || 'application/json';\n    } else {\n      throw new Error('transport.read.url must be set to use ElasticSearchDataSource');\n    }\n\n    const _model = initOptions.schema && initOptions.schema.model;\n    if (!_model) {\n      throw new Error('transport.schema.model must be set to use ElasticSearchDataSource');\n    }\n    if (_model.esMapping) {\n      _model.fields = _model.fields || {};\n      data.ElasticSearchDataSource.kendoFieldsFromESMapping(\n        _model.esMapping, _model, _model.fields);\n    } else {\n      if (!_model.fields) {\n        throw new Error('transport.schema.model.fields/esMapping must be set');\n      }\n      fields.fill(_model.fields, _model);\n    }\n\n    // Get sets of nesting levels\n    const _nestedFields = {};\n    const _subTypes = {};\n    Object.keys(_model.fields).forEach(fieldKey => {\n      const field = _model.fields[fieldKey];\n      if (field.esNestedPath) {\n        _nestedFields[field.esNestedPath] = _nestedFields[field.esNestedPath] || [];\n        _nestedFields[field.esNestedPath].push(field.esName);\n      }\n      if (field.esParentType) {\n        _subTypes[field.esParentType] = _subTypes[field.esParentType] || [];\n        _subTypes[field.esParentType].push(field.esName);\n      }\n      if (field.esChildType) {\n        _subTypes[field.esChildType] = _subTypes[field.esChildType] || [];\n        _subTypes[field.esChildType].push(field.esName);\n      }\n    });\n\n    // Prepare the content of the query that will be sent to ES\n    // based on the kendo data structure\n    initOptions.transport.parameterMap = function (data) {\n      const sortParams = sort.prepareParams(data.sort, data.group, data.columns);\n\n      const esParams = {};\n      if (data.skip) {\n        esParams.from = data.skip;\n      }\n      if (data.take) {\n        esParams.size = data.take;\n      }\n\n      if (initOptions.aggregationsOnly) {\n        esParams.from = 0;\n        esParams.size = 0;\n      }\n\n      // Transform kendo sort params in a ES sort list\n      esParams.sort = sort.kendo2es(sortParams, _model.fields);\n\n      // Transform kendo filters into a ES query using a query_string request\n      esParams.query = {\n        filtered: {\n          filter: filters.kendo2es(data.filter || [], _model.fields)\n        }\n      };\n\n      // Add a top level inner_hits definition for nested/parent/child docs\n      esParams['inner_hits'] = esUtils.innerHits(\n        _nestedFields,\n        _model.esMappingKey,\n        _subTypes,\n        esParams.sort,\n        esParams.query.filtered.filter\n      );\n\n      // Fetch only the required list of fields from ES\n      esParams._source = Object.keys(_model.fields)\n        .filter(k =>\n          !_model.fields[k].esNestedPath &&\n          !_model.fields[k].esParentType &&\n          !_model.fields[k].esChildType)\n        .map(k => _model.fields[k].esName);\n\n      // Transform kendo aggregations into ES aggregations\n      esParams.aggs = aggregations.kendo2es(\n        data.aggregate,\n        _model.fields,\n        _nestedFields,\n        _model.esMappingKey,\n        esParams.query.filtered.filter\n      );\n\n      // Transform Kendo group instruction into an ES bucket aggregation\n      groups.kendo2es(\n        esParams.aggs,\n        data.group,\n        _model.fields,\n        _nestedFields,\n        _model.esMappingKey,\n        esParams.query.filtered.filter\n      );\n\n      return JSON.stringify(esParams);\n    };\n\n    const schema = initOptions.schema;\n\n    // Parse the results from elasticsearch to return data items,\n    // total and aggregates for Kendo grid\n    schema.parse = function (response) {\n      const items = dataItems.fromHits(response.hits.hits, _model.fields);\n\n      // cheat. Root aggregations used as a pseudo buckets with doc_count = total number of results\n      // used to process missing counts\n      if (response.aggregations) {\n        response.aggregations.doc_count = response.hits.total;\n      }\n      const aggregates = aggregations.es2kendo(response.aggregations);\n      const grps = groups.es2kendo(items, response.aggregations, _model.fields, initOptions.aggregationsOnly);\n\n      return {\n        total: response.hits.total,\n        data: items,\n        aggregates: aggregates,\n        groups: grps\n      };\n    };\n\n    schema.aggregates = response => response.aggregates;\n    schema.groups = response => response.groups;\n\n    schema.data = schema.data || 'data';\n    schema.total = schema.total || 'total';\n    schema.model.id = schema.model.id || '_id';\n\n    initOptions.serverFiltering = true;\n    initOptions.serverSorting = true;\n    initOptions.serverPaging = true;\n    initOptions.serverAggregates = true;\n    initOptions.serverGrouping = true;\n\n    data.DataSource.fn.init.call(this, initOptions);\n  }\n});\n\ndata.ElasticSearchDataSource.kendoFieldsFromESMapping = fields.fromMapping;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/kendo-elasticsearch.js\n **/","export const kendo2es = _kendo2es;\nexport const prepareParams = _prepareParams;\n\n// Transform sort instruction into some object suitable for Elasticsearch\n// Also deal with sorting the different nesting levels\nfunction _kendo2es(sort, fields, nestedPath) {\n  return sort.filter(sortItem => {\n    const field = fields[sortItem.field];\n    if (!field) return false;\n    return field.esNestedPath === nestedPath ||\n      field.esParentType === nestedPath ||\n      field.esChildType === nestedPath;\n  }).map(sortItem => {\n    return {\n      [fields[sortItem.field].esFilterName]: {\n        order: sortItem.dir,\n        missing: '_last',\n        mode: sortItem.dir === 'asc' ? 'min' : 'max'\n      }\n    };\n  });\n};\n\n// Prepare sort parameters for easier transformation to ES later on\nfunction _prepareParams(sort, groups) {\n  // first fix the type of the param that can be object of group\n  let sortArray = [];\n  if (sort && sort.constructor === Array) {\n    sortArray = sort;\n  } else {\n    if (sort) {\n      sortArray.push(sort);\n    }\n  }\n\n  // Sort instructions for the groups are first\n  let fullSort = [];\n  (groups || []).forEach(function (group) {\n    const matchingSort = sortArray.filter(function (sortItem) {\n      return sortItem.field === group.field;\n    });\n    if (matchingSort.length) {\n      fullSort.push(matchingSort[0]);\n      sortArray.splice(sortArray.indexOf(matchingSort[0]), 1);\n    } else {\n      fullSort.push({\n        field: group.field,\n        dir: group.dir || 'asc'\n      });\n    }\n  });\n\n  // Then original sort instructions are added\n  fullSort = fullSort.concat(sortArray);\n\n  return fullSort;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/sort.js\n **/","import * as aggregations from './aggregations';\nimport * as dataItems from './data-items';\nexport const kendo2es = _kendo2es;\nexport const es2kendo = _es2kendo;\n\n// Transform kendo groups declaration into ES bucket aggregations\nfunction _kendo2es(aggs, groups, fields, nestedFields, esMappingKey, filter) {\n  let previousLevelAggs = [aggs];\n  let previousLevelNestedPath = null;\n  groups.forEach(group => {\n    const field = fields[group.field];\n    const nextLevelAggs = _kendoGroup2es(group, fields, nestedFields, esMappingKey, filter);\n\n    const aggs = {};\n    if (field.esNestedPath && field.esNestedPath.indexOf(previousLevelNestedPath) !== 0) {\n      aggs[field.esNestedPath + '_nested'] = aggs[field.esNestedPath + '_nested'] || {\n        nested: {\n          path: field.esFullNestedPath\n        },\n        aggs: {}\n      };\n      aggs[field.esNestedPath + '_nested'].aggs[group.field + '_group'] = nextLevelAggs.group;\n      aggs[field.esNestedPath + '_nested'].aggs[group.field + '_missing'] = nextLevelAggs.missing;\n    } else {\n      aggs[group.field + '_group'] = nextLevelAggs.group;\n      aggs[group.field + '_missing'] = nextLevelAggs.missing;\n    } // 3rd case for nested path that is not child of the previous group\n\n    previousLevelAggs.forEach(previousLevelAgg => {\n      Object.keys(aggs).forEach(aggKey => {\n        previousLevelAgg[aggKey] = aggs[aggKey];\n      });\n    });\n    previousLevelAggs = Object.keys(nextLevelAggs).map(aggKey => {\n      return nextLevelAggs[aggKey].aggregations;\n    });\n    previousLevelNestedPath = field.esNestedPath;\n  });\n}\n\nfunction _kendoGroup2es(group, fields, nestedFields, esMappingKey, filter) {\n  const field = fields[group.field];\n  const groupAgg = {};\n  const missingAgg = {};\n\n  // Look for a aggregate defined on group field\n  // Used to customize the bucket aggregation for range, histograms, etc.\n  let fieldAggregate;\n  const groupAggregates = [];\n  (group.aggregates || []).forEach(aggregate => {\n    // We exclude strings that are not concerned by specific aggregations (only terms buckets)\n    // And cause bugs when counting cardinality on own group.\n    if (aggregate.field === group.field && field.type !== 'string') {\n      fieldAggregate = aggregate;\n    } else {\n      groupAggregates.push(aggregate);\n    }\n  });\n\n  if (fieldAggregate) {\n\n    // We support date histogramms if a 'interval' key is passed\n    // to the group definition\n    groupAgg[fieldAggregate.aggregate] = {\n      field: field.esAggName\n    };\n    if (fieldAggregate.interval) {\n      groupAgg[fieldAggregate.aggregate].interval = fieldAggregate.interval;\n    }\n  } else {\n\n    // Default is a term bucket aggregation\n    // if used on a not analyzed field or subfield\n    // it will create a group for each value of the field\n    groupAgg.terms = {\n      field: field.esAggName,\n      size: 0\n    };\n  }\n\n  missingAgg.missing = {\n    field: field.esAggName\n  };\n\n  const esGroupAggregates = aggregations.kendo2es(\n    groupAggregates,\n    fields,\n    nestedFields,\n    esMappingKey,\n    filter,\n    field.esNestedPath\n  );\n  groupAgg.aggregations = esGroupAggregates;\n  missingAgg.aggregations = esGroupAggregates;\n\n  return {\n    group: groupAgg,\n    missing: missingAgg\n  };\n}\n\n// Extraction aggregations from ES query result that will be used to group\n// data items\nfunction _parseGroupAggregations(aggregations, missingNested) {\n  let groupAggregations = Object.keys(aggregations).filter(aggKey => {\n    return aggKey.substr(aggKey.length - 6) === '_group';\n  }).map(aggKey => {\n    const fieldKey = aggKey.substr(0, aggKey.length - 6);\n    if (missingNested) {\n      aggregations[fieldKey + '_missing'].doc_count += missingNested;\n    }\n    return {\n      group: aggregations[aggKey],\n      missing: aggregations[fieldKey + '_missing'],\n      fieldKey: fieldKey\n    };\n  });\n\n  // extract other group aggregations from nested aggregations\n  Object.keys(aggregations)\n    .filter(aggKey => aggKey.substr(aggKey.length - 7) === '_nested')\n    .forEach(aggKey => {\n      // 'missing' count on a nested group aggregation =\n      //      'document without nested objects' + 'nested objects with missing field'\n      // and 'document without nested objects' is equal to 'number of documents' - 'number of nested documents'\n      const missingNested = aggregations.doc_count - aggregations[aggKey].doc_count;\n      groupAggregations =\n        groupAggregations.concat(_parseGroupAggregations(aggregations[aggKey], missingNested));\n    });\n\n  return groupAggregations;\n}\n\n// Transform ES bucket aggregations into kendo groups of data items\n// See doc here for format of groups:\n// http://docs.telerik.com/KENDO-UI/api/javascript/data/datasource#configuration-schema.groups\nfunction _es2kendo(items, aggregations, fields, aggregationsOnly) {\n  let allGroups = [];\n  if (aggregations) {\n    const groupAggregations = _parseGroupAggregations(aggregations);\n\n    // Find aggregations that are grouping aggregations (ie buckets in ES)\n    groupAggregations.forEach(groupAggregation => {\n      let groups = [];\n\n      const groupDefs = _esAgg2kendo(\n        groupAggregation.group,\n        groupAggregation.missing,\n        groupAggregation.fieldKey);\n\n      if (!aggregationsOnly) {\n        // Then distribute the data items in the groups\n        groups = dataItems.fillInGroups(groupDefs, items, fields[groupAggregation.fieldKey]);\n      } else {\n        groups = groupDefs.keys.map(function (key) {\n          return groupDefs.map[key];\n        });\n      }\n\n      // Case when there is subgroups. Solve it recursively.\n      let hasSubgroups = false;\n      if (groupAggregation.group.buckets && groupAggregation.group.buckets[0]) {\n        Object.keys(groupAggregation.group.buckets[0]).forEach(bucketKey => {\n          if (bucketKey.substr(bucketKey.length - 6) === '_group' ||\n            bucketKey.substr(bucketKey.length - 7) === '_nested') {\n            hasSubgroups = true;\n          }\n        });\n      }\n      groups.forEach(group => {\n        if (hasSubgroups) {\n          group.hasSubgroups = true;\n          group.items = _es2kendo(group.items, group.bucket, fields, aggregationsOnly);\n        }\n        delete group.bucket;\n      });\n\n      allGroups = allGroups.concat(groups);\n    });\n  }\n\n  return allGroups;\n}\n\n// Transform a single bucket aggregation into kendo groups definitions\n// Does not fill up the data items\nfunction _esAgg2kendo(groupAggregation, missingAggregation, fieldKey) {\n  const groupsMap = {};\n  const groupKeys = [];\n\n  // Each bucket in ES aggregation result is a group\n  groupAggregation.buckets.forEach(bucket => {\n    const bucketKey = bucket.key_as_string || bucket.key;\n    groupKeys.push(bucketKey);\n    groupsMap[bucketKey] = {\n      field: fieldKey,\n      value: bucketKey,\n      hasSubgroups: false,\n      aggregates: aggregations.es2kendo(bucket),\n      items: [],\n      bucket: bucket\n    };\n    groupsMap[bucketKey].aggregates[fieldKey] = {\n      count: bucket.doc_count\n    };\n  });\n\n  // Special case for the missing value\n  groupsMap[''] = {\n    field: fieldKey,\n    value: '',\n    hasSubgroups: false,\n    aggregates: aggregations.es2kendo(missingAggregation),\n    items: [],\n    bucket: missingAggregation\n  };\n  groupsMap[''].aggregates[fieldKey] = {\n    count: missingAggregation.doc_count\n  };\n\n  return {\n    map: groupsMap,\n    keys: groupKeys\n  };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/groups.js\n **/","import * as esUtils from './es-utils';\nexport const kendo2es = _kendo2es;\nexport const es2kendo = _es2kendo;\n\nconst kendoToESAgg = {\n  count: 'cardinality',\n  min: 'min',\n  max: 'max',\n  sum: 'sum',\n  average: 'avg'\n};\n\n// Transform kendo aggregates into ES metric aggregations\nfunction _kendo2es(aggregate, fields, nestedFields, esMappingKey, filter, groupNestedPath) {\n  const esAggs = {};\n\n  (aggregate || []).forEach(aggItem => {\n    const field = fields[aggItem.field];\n    let nestedPath = field.esNestedPath;\n    let aggsWrapper = esAggs;\n    if (groupNestedPath !== nestedPath) {\n      const previousPathParts = [];\n      if (groupNestedPath && nestedPath.indexOf(groupNestedPath) !== 0) {\n        esAggs.group_reverse_nested = esAggs.group_reverse_nested || {\n          reverse_nested: {},\n          aggregations: {}\n        };\n        aggsWrapper = esAggs.group_reverse_nested.aggregations;\n      } else if (groupNestedPath) {\n        nestedPath = nestedPath.substr(groupNestedPath.length + 1, nestedPath.length);\n      }\n\n      nestedPath.split('.').forEach(nestedPathPart => {\n        previousPathParts.push(nestedPathPart);\n        const currentPath = groupNestedPath ?\n          groupNestedPath + '.' + previousPathParts.join('.') :\n          previousPathParts.join('.');\n        const fullCurrentPath = esMappingKey ? esMappingKey + '.' + currentPath : currentPath;\n        const currentFields = nestedFields[currentPath];\n        if (!currentFields) return;\n        if (!aggsWrapper[currentPath]) {\n          aggsWrapper[currentPath + '_filter_nested'] = aggsWrapper[currentPath + '_filter_nested'] || {\n            nested: {\n              path: fullCurrentPath\n            },\n            aggregations: {}\n          };\n          aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'] =\n            aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'] || {\n              filter: esUtils.innerHitsFilter(fullCurrentPath, null, filter),\n              aggregations: {}\n            };\n        }\n        aggsWrapper = aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'].aggregations;\n      });\n    }\n\n    aggsWrapper[aggItem.field + '_' + aggItem.aggregate] = {};\n    aggsWrapper[aggItem.field + '_' + aggItem.aggregate][kendoToESAgg[aggItem.aggregate]] = {\n      field: field.esAggName\n    };\n  });\n\n  return esAggs;\n}\n\n// Transform aggregation results from a ES query to kendo aggregates\nfunction _es2kendo(aggregations, previousAggregates) {\n  const aggregates = previousAggregates || {};\n  aggregations = aggregations || {};\n  Object.keys(aggregations).forEach(aggKey => {\n    if (!aggregations[aggKey]) return;\n    ['count', 'min', 'max', 'average', 'sum'].forEach(aggType => {\n      const suffixLength = aggType.length + 1;\n      if (aggKey.substr(aggKey.length - suffixLength) === '_' + aggType) {\n        const fieldKey = aggKey.substr(0, aggKey.length - suffixLength);\n        aggregates[fieldKey] = aggregates[fieldKey] || {};\n        aggregates[fieldKey][aggType] = aggregations[aggKey].value;\n      }\n    });\n\n    if (aggKey.substr(aggKey.length - 7) === '_nested' || aggKey.substr(aggKey.length - 7) === '_filter') {\n      // recursivity on intermediate levels\n      _es2kendo(aggregations[aggKey], aggregates);\n    }\n\n  });\n  return aggregates;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/aggregations.js\n **/","// Some function that work on ES queries to deal with nested levels and other\n// difficulties\n\nexport const innerHits = _innerHits;\nexport const innerHitsFilter = _innerHitsFilter;\n\n// Get a root inner_hits definition to fetch all nested/parent/child docs\nfunction _innerHits(nestedFields, esMappingKey, subTypes, sort, filter) {\n  const innerHits = {};\n  Object.keys(nestedFields).forEach(nestedPath => {\n    let previousLevelInnerHits = innerHits;\n    const previousPathParts = [];\n    nestedPath.split('.').forEach(nestedPathPart => {\n      previousPathParts.push(nestedPathPart);\n      const currentPath = previousPathParts.join('.');\n      const fullCurrentPath = esMappingKey ? esMappingKey + '.' + currentPath : currentPath;\n      const currentFields = nestedFields[currentPath];\n      if (!currentFields) {\n        return;\n      }\n      if (!previousLevelInnerHits[currentPath]) {\n        previousLevelInnerHits[currentPath] = {\n          path: {\n            [fullCurrentPath]: {\n              _source: currentFields,\n              size: 10000,\n              sort: sort,\n              query: {\n                filtered: {\n                  filter: _innerHitsFilter(fullCurrentPath, null, filter)\n                }\n              }\n            }\n          }\n        };\n      }\n      if (currentPath !== nestedPath) {\n        previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits =\n          previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits || {};\n        previousLevelInnerHits =\n          previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits;\n      }\n    });\n  });\n\n  Object.keys(subTypes).forEach(subType => {\n    const currentFields = subTypes[subType];\n    innerHits[subType] = {\n      type: {\n        [subType]: {\n          _source: currentFields,\n          size: 10000,\n          sort: sort,\n          query: {\n            filtered: {\n              filter: _innerHitsFilter(null, subType, filter)\n            }\n          }\n        }\n      }\n    };\n  });\n  return innerHits;\n}\n\n// Traverse the filter to keep only the parts that concern\n// a nesting path\nfunction _innerHitsFilter(nestedPath, subType, filter) {\n  filter = $.extend(true, {}, filter);\n  const logicFilter = filter.or || filter.and;\n  if (logicFilter) {\n    logicFilter.filters = logicFilter.filters.filter(childFilter => {\n      return childFilter.and || childFilter.or ||\n        (childFilter.nested && childFilter.nested.path === nestedPath) ||\n        (childFilter.not && childFilter.not.nested && childFilter.not.nested.path === nestedPath) ||\n        (childFilter.has_child && childFilter.has_child.type === subType) ||\n        (childFilter.not && childFilter.not.has_child && childFilter.not.has_child.type === subType) ||\n        (childFilter.has_parent && childFilter.has_parent.type === subType) ||\n        (childFilter.not && childFilter.not.has_parent && childFilter.not.has_parent.type === subType);\n    }).map(childFilter => {\n      if (childFilter.nested) {\n        return childFilter.nested.filter;\n      } else if (childFilter.not && childFilter.not.nested) {\n        return {\n          not: childFilter.not.nested.filter\n        };\n      } else if (childFilter.has_child) {\n        return childFilter.has_child.filter;\n      } else if (childFilter.not && childFilter.not.has_child) {\n        return {\n          not: childFilter.not.has_child.filter\n        };\n      } else if (childFilter.has_parent) {\n        return childFilter.has_parent.filter;\n      } else if (childFilter.not && childFilter.not.has_parent) {\n        return {\n          not: childFilter.not.has_parent.filter\n        };\n      } else {\n        return _innerHitsFilter(nestedPath, childFilter);\n      }\n    });\n  }\n  return filter;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/es-utils.js\n **/","export const fillInGroups = _fillInGroups;\nexport const fromHits = _fromHits;\n\n// distribute data items in groups based on a field value\nfunction _fillInGroups(groupDefs, dataItems, field) {\n  const groups = [];\n  dataItems.forEach(function (dataItem) {\n    let group = groupDefs.map[dataItem[field.key] || ''];\n\n    // If no exact match, then we may be in some range aggregation ?\n    if (!group) {\n      const fieldValue = field.type === 'date' ? new Date(dataItem[field.key]) : dataItem[field.key];\n\n      for (let i = 0; i < groupDefs.keys.length; i++) {\n        const groupDefValue = field.type === 'date' ? new Date(groupDefs.keys[i]) : groupDefs.keys[i];\n        if (fieldValue >= groupDefValue) {\n          const groupDefNextValue = groupDefs.keys[i + 1] && (field.type === 'date' ?\n            new Date(groupDefs.keys[i + 1]) : groupDefs.keys[i + 1]);\n          if (!groupDefNextValue || fieldValue < groupDefNextValue) {\n            group = groupDefs.map[groupDefs.keys[i]];\n          }\n        }\n      }\n    }\n\n    if (!group) {\n      throw new Error('No group found, val: ' + dataItem[field.key] + ' field: ' + field.key);\n    }\n    group.items.push(dataItem);\n    if (group.items.length === 1) {\n      groups.push(group);\n    }\n  });\n  return groups;\n}\n\n// Mimic fetching values from _source as the 'fields' functionality\n// would have done it.\n// We do not use the native 'fields' due to this bug:\n// https://github.com/elastic/elasticsearch/issues/14475\nfunction _getValuesFromSource(source, pathParts) {\n  let values = [];\n  const value = source[pathParts[0]];\n  if (value === undefined) {\n    return [];\n  }\n\n  if (pathParts.length > 1) {\n\n    // recursivity is not over, there remain some path parts\n    if ($.isArray(value)) {\n      value.forEach(function (valueItem) {\n        values = values.concat(_getValuesFromSource(valueItem, pathParts.slice(1)));\n      });\n    } else {\n      values = _getValuesFromSource(value, pathParts.slice(1));\n    }\n  } else {\n\n    // recursivity, we should be in a leaf value\n    if ($.isArray(value)) {\n      values = value;\n    } else {\n      values = [value];\n    }\n  }\n  return values;\n}\n\n// Transform hits from the ES query in to data items for kendo grid\n// The difficulty is that hits can contain inner hits and that some\n// fields can be multi-valued\nfunction _fromHits(hits, fields, innerPath) {\n\n  let dataItems = [];\n  hits.forEach(hit => {\n    const hitSource = hit._source || {};\n    const dataItem = {};\n\n    dataItem.id = [hit._id];\n    Object.keys(fields).filter(fieldKey => {\n      const field = fields[fieldKey];\n\n      // Keep only the fields that are part of this nested/parent/child\n      if (innerPath === undefined) {\n        return !(field.esNestedPath || field.esChildType || field.esParentType);\n      } else {\n        return field.esNestedPath === innerPath ||\n          field.esChildType === innerPath ||\n          field.esParentType === innerPath;\n      }\n    }).forEach(function (fieldKey) {\n      const field = fields[fieldKey];\n      let values = _getValuesFromSource(hitSource, field.esNameSplit);\n\n      // special case field that is a date deep down by displayed as a number\n      if (field.duration) {\n        if (!moment) {\n          throw new Error('Working on durations requires to load momentjs library');\n        }\n      }\n\n      if (field.duration === 'beforeToday') {\n        values = values.map(value => {\n          return moment().startOf('day').diff(moment(value).startOf('day'), 'days');\n        });\n      }\n\n      if (field.duration === 'afterToday') {\n        values = values.map(value => {\n          return moment(value).startOf('day').diff(moment().startOf('day'), 'days');\n        });\n      }\n\n      if (values) {\n        if (field.esMultiSplit) {\n          if (values && values.length) {\n            dataItem[fieldKey] = values;\n          } else {\n            dataItem[fieldKey] = [null];\n          }\n        } else {\n          dataItem[fieldKey] = values.join(field.esMultiSeparator || '\\n');\n        }\n      }\n    });\n\n    // Multiply and fill items based on nesting levels\n    let splittedItems = [dataItem];\n    Object.keys(hit.inner_hits || {}).forEach(function (innerHitKey) {\n      const nestedItems =\n        _fromHits(hit.inner_hits[innerHitKey].hits.hits, fields, innerHitKey);\n      const newSplittedDataItems = [];\n      splittedItems.forEach(function (splittedItem) {\n        if (nestedItems.length) {\n          nestedItems.forEach(function (nestedItem) {\n            const mergedItem = {};\n            Object.keys(nestedItem).forEach(function (key) {\n              mergedItem[key] = nestedItem[key];\n            });\n            Object.keys(splittedItem).forEach(function (key) {\n              mergedItem[key] = splittedItem[key];\n            });\n            newSplittedDataItems.push(mergedItem);\n          });\n        } else {\n          newSplittedDataItems.push(splittedItem);\n        }\n      });\n      splittedItems = newSplittedDataItems;\n    });\n\n    dataItems = dataItems.concat(splittedItems);\n\n  });\n  return _splitMultiValues(dataItems);\n}\n\n// Split lines of data items based on their optionally multipl items\n// Example: [{a:[1,2],b:[3]}] -> [{a:1,b:3},{a:2,b:3}]\nfunction _splitMultiValues(items) {\n  let results = [];\n\n  // Iterates on items in the array and multiply based on multiple values\n  items.forEach(item => {\n    let itemResults = [{}];\n\n    // Iterate on properties of item\n    Object.keys(item).forEach(k => {\n      const partialItemResults = [];\n\n      // Iterate on the multiple values of this property\n      if (item[k] && item[k].constructor === Array) {\n        item[k].forEach(val => {\n          itemResults.forEach(result => {\n\n            // Clone the result to create variants with the different values of current key\n            const newResult = {};\n            Object.keys(result).forEach(k2 => newResult[k2] = result[k2]);\n            newResult[k] = val;\n            partialItemResults.push(newResult);\n          });\n        });\n      } else {\n        itemResults.forEach(result => {\n          result[k] = item[k];\n          partialItemResults.push(result);\n        });\n      }\n      itemResults = partialItemResults;\n    });\n\n    results = results.concat(itemResults);\n  });\n  return results;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/data-items.js\n **/","export const kendo2es = _kendo2es;\n\n// Transform a tree of kendo filters into a tree of ElasticSearch filters\nfunction _kendo2es(kendoFilters, fields) {\n  let filters;\n\n  // logicalConnective can be \"and\" or \"or\"\n  let logicalConnective = 'and';\n\n  if (kendoFilters.operator) {\n    filters = [kendoFilters];\n  } else if (kendoFilters.logic) {\n    logicalConnective = kendoFilters.logic;\n    filters = kendoFilters.filters || [];\n  } else if (kendoFilters.constructor === Array) {\n    filters = kendoFilters;\n  } else {\n    throw new Error('Unsupported filter object: ' + kendoFilters);\n  }\n\n  const esFilters = [];\n  const esNestedFilters = {};\n\n  filters.forEach(filter => {\n    if (filter.logic) {\n      esFilters.push(_kendo2es(filter, fields));\n    } else {\n      const field = fields[filter.field];\n      if (!field) {\n        throw new Error('Unknown field in filter: ' + filter.field);\n      }\n      let esFilter = {\n        query: {\n          query_string: {\n            query: _filterParam(filter, fields),\n            // support uppercase/lowercase and accents\n            analyze_wildcard: true\n          }\n        }\n      };\n      if (field.esNestedPath) {\n        const esNestedFilter = esNestedFilters[field.esNestedPath] || {\n          nested: {\n            path: field.esFullNestedPath,\n            filter: {}\n          }\n        };\n        esNestedFilter.nested.filter[logicalConnective] = esNestedFilter.nested.filter[logicalConnective] || {\n          filters: []\n        };\n        esNestedFilter.nested.filter[logicalConnective].filters.push(esFilter);\n        if (!esNestedFilters[field.esNestedPath]) {\n          esFilter = esNestedFilters[field.esNestedPath] = esNestedFilter;\n        } else {\n          esFilter = null;\n        }\n      } else if (field.esParentType) {\n        esFilter = {\n          has_parent: {\n            type: field.esParentType,\n            filter: esFilter\n          }\n        };\n      } else if (field.esChildType) {\n        esFilter = {\n          has_child: {\n            type: field.esChildType,\n            filter: esFilter\n          }\n        };\n      }\n\n      if (esFilter) {\n        esFilters.push(esFilter);\n      }\n\n    }\n  });\n\n  const result = {};\n  result[logicalConnective] = {\n    filters: esFilters\n  };\n  return result;\n}\n\n// Transform a single kendo filter in a string\n// that can be used to compose a ES query_string query\nfunction _filterParam(kendoFilter, fields) {\n\n  // Boolean filter seems to forget the operator sometimes\n  kendoFilter.operator = kendoFilter.operator || 'eq';\n\n  // Use the filter field name except for contains\n  // that should use classical search instead of regexp\n  const field = fields[kendoFilter.field];\n\n  // special case field that is a date deep down by displayed as a number\n  if (field.duration) {\n    if (!moment) {\n      throw new Error('Working on durations requires to load momentjs library');\n    }\n  }\n\n  if (field.duration === 'beforeToday') {\n    kendoFilter.value = moment().startOf('day').subtract(kendoFilter.value, 'days').format();\n    if (kendoFilter.operator === 'lt') kendoFilter.operator = 'gt';\n    else if (kendoFilter.operator === 'lte') kendoFilter.operator = 'gte';\n    else if (kendoFilter.operator === 'gt') kendoFilter.operator = 'lt';\n    else if (kendoFilter.operator === 'gte') kendoFilter.operator = 'lte';\n  }\n\n  if (field.duration === 'afterToday') {\n    kendoFilter.value = moment().startOf('day').add(kendoFilter.value, 'days').format();\n  }\n\n  let fieldName;\n  if (kendoFilter.operator === 'search') {\n    fieldName = field.esSearchName;\n  } else {\n    fieldName = field.esFilterName;\n  }\n\n  const fieldEscaped = _asESParameter(fieldName);\n  const valueEscaped = _asESParameter(kendoFilter.value, kendoFilter.operator);\n\n  const simpleBinaryOperators = {\n    eq: '',\n    search: '',\n    lt: '<',\n    lte: '<=',\n    gt: '>',\n    gte: '>='\n  };\n\n  if (simpleBinaryOperators[kendoFilter.operator] !== void 0) {\n    const esOperator = simpleBinaryOperators[kendoFilter.operator];\n    return fieldEscaped + ':' + esOperator + valueEscaped;\n  } else {\n    let expression;\n    switch (kendoFilter.operator) {\n      case 'neq':\n        return 'NOT (' + fieldEscaped + ':' + valueEscaped + ')';\n      case 'contains':\n        return '(' + fieldEscaped + ':*' + valueEscaped + '*)';\n      case 'doesnotcontain':\n        return 'NOT (' + fieldEscaped + ':*' + valueEscaped + '*)';\n      case 'startswith':\n        return fieldEscaped + ':' + valueEscaped + '*';\n      case 'endswith':\n        return fieldEscaped + ':*' + valueEscaped;\n      case 'missing':\n        if (field.esNestedPath || field.esParentType || field.esChildType) {\n          // missing in a nested document should be implemented as a \"not nested exists\"\n          // but this is not really doable when mixing with other filters\n          // see https://github.com/elastic/elasticsearch/issues/3495\n          throw new Error('missing filter is not supported on nested fields');\n        }\n        expression = '_missing_:' + fieldEscaped;\n        if (field.type === 'string') {\n          expression += ' OR (' + fieldEscaped + ':\"\")';\n        }\n        return expression;\n      case 'exists':\n        expression = '_exists_:' + fieldEscaped;\n        if (field.type === 'string') {\n          expression += ' AND NOT(' + fieldEscaped + ':\"\")';\n        }\n        return expression;\n      default:\n        throw new Error('Unsupported Kendo filter operator: ' + kendoFilter.operator);\n    }\n  }\n}\n\n// Escape values so that they are suitable as an elasticsearch query_string query parameter\nconst escapeValueRegexp = /[+\\-&|!()\\{}\\[\\]^:\"~*?:\\/ ]/g;\nconst escapeSearchValueRegexp = /[+\\-&|!()\\{}\\[\\]^:~:\\/]/g;\n\nfunction _asESParameter(value, operator) {\n  if (value.constructor === Date) {\n    value = value.toISOString();\n  } else if (typeof value === 'boolean' || typeof value === 'number') {\n    value = '' + value;\n  }\n\n  // For the special 'search' operator we allow some wildcard and other characters\n  if (operator === 'search') {\n    value = value.replace('\\\\', '\\\\\\\\');\n    if (((value.match(/\"/g) || []).length % 2) === 1) {\n      value = value.replace(/\"/g, '\\\\\"');\n    }\n    value = value.replace(escapeSearchValueRegexp, '\\\\$&');\n    return value;\n  }\n  return value.replace('\\\\', '\\\\\\\\').replace(escapeValueRegexp, '\\\\$&');\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/filters.js\n **/","export const fromMapping = _fromMapping;\nexport const fill = _fill;\n\n// Transform a mapping definition from ElasticSearch into a kendo fields map\n// This utility function is exposed as it can be interesting to use it before instantiating\n// the actual datasource\n// @param mapping - An elasticsearch mapping\nfunction _fromMapping(\n  mapping, model, fields, prefix, esPrefix, nestedPath) {\n  fields = fields || {};\n  prefix = prefix || '';\n  Object.keys(mapping.properties || {}).forEach(propertyKey => {\n    const property = mapping.properties[propertyKey];\n    const curedPropertyKey = asKendoPropertyKey(propertyKey);\n    const prefixedName = prefix ? prefix + '_' + curedPropertyKey : curedPropertyKey;\n    const esName = esPrefix ? esPrefix + '.' + propertyKey : propertyKey;\n\n    if (property.type === 'nested') {\n      // Case where the property is a nested object\n      const subNestedPath = nestedPath ? nestedPath + '.' + esName : esName;\n      _fromMapping(property, model, fields, prefixedName, '', subNestedPath);\n    } else if (property.properties) {\n      // Case where the property is a non nested object with properties\n      _fromMapping(property, model, fields, prefixedName, esName, nestedPath);\n    } else if (property.type === 'object') {\n      // Case where the property is a non nested object with zero subproperties. do nothing.\n    } else {\n      // Finally case of a leaf property\n      const field = fields[prefixedName] = fields[prefixedName] || {};\n\n      // if the field was already defined with a nested path,\n      // then we are in the case of field both nested and included in parent\n      // then we should not consider it as a real leaf property\n      if (!field.esNestedPath) {\n        field.type = field.type || property.type;\n\n        // ES supports a variety of numeric types. In JSON and kendo it is simply 'number'.\n        if (['float', 'double', 'integer', 'long', 'short', 'byte'].indexOf(field.type) !== -1) {\n          field.type = 'number';\n        }\n\n        // Default is splitting data lines except for string fields\n        if (field.type !== 'string') {\n          field.esMultiSplit = true;\n        }\n\n        if (nestedPath) {\n          field.esNestedPath = nestedPath;\n        }\n        field.esName = esName;\n\n        // When the field is not analyzed, the default string subfields should not be applied.\n        if (property.index === 'not_analyzed') {\n          field.esSearchSubField = null;\n          field.esFilterSubField = null;\n          field.esAggSubField = null;\n        }\n      }\n    }\n  });\n\n  _fill(fields, model);\n\n  return fields;\n};\n\n// Associate Kendo field names to ElasticSearch field names.\n// We have to allow ElasticSearch field names to be different\n// because ES likes an \"@\" and/or dots in field names while Kendo fails on that.\n// Filtering and aggregating can be based on a a different field if esFilterName\n// or esAggName are defined or on a subfield if esFilterSubField or esAggSubField are defined.\n// Typical use case is the main field is analyzed, but it has a subfield that is not\n// (or only with a minimal analyzer)\nfunction _fill(fields, model) {\n  for (const k in fields) {\n    if (fields.hasOwnProperty(k)) {\n      const field = fields[k];\n      field.key = k;\n      field.esName = field.esName || k;\n      field.esNameSplit = field.esName.split('.');\n      field.esFullNestedPath = field.esNestedPath;\n      if (model.esMappingKey) {\n        field.esFullNestedPath = model.esMappingKey + '.' + field.esFullNestedPath;\n      }\n      if (!field.esSearchName) {\n        field.esSearchName = field.esName;\n        if (field.hasOwnProperty('esSearchSubField')) {\n          if (field.esSearchSubField) {\n            field.esSearchName += '.' + field.esSearchSubField;\n          }\n        } else if (field.type === 'string' &&\n          model.esStringSubFields &&\n          model.esStringSubFields.search) {\n          field.esSearchName += '.' + model.esStringSubFields.search;\n        }\n        if (field.esNestedPath) {\n          field.esSearchName = field.esNestedPath + '.' + field.esSearchName;\n        }\n      }\n      if (!field.esFilterName) {\n        field.esFilterName = field.esName;\n        if (field.hasOwnProperty('esFilterSubField')) {\n          if (field.esFilterSubField) {\n            field.esFilterName += '.' + field.esFilterSubField;\n          }\n        } else if (field.type === 'string' &&\n          model.esStringSubFields &&\n          model.esStringSubFields.filter) {\n          field.esFilterName += '.' + model.esStringSubFields.filter;\n        }\n        if (field.esNestedPath) {\n          field.esFilterName = field.esNestedPath + '.' + field.esFilterName;\n        }\n      }\n      if (!field.esAggName) {\n        field.esAggName = field.esName;\n        if (field.hasOwnProperty('esAggSubField')) {\n          if (field.esAggSubField) {\n            field.esAggName += '.' + field.esAggSubField;\n          }\n        } else if (field.type === 'string' &&\n          model.esStringSubFields &&\n          model.esStringSubFields.agg) {\n          field.esAggName += '.' + model.esStringSubFields.agg;\n        }\n        if (field.esNestedPath) {\n          field.esAggName = field.esFullNestedPath + '.' + field.esAggName;\n        }\n      }\n    }\n  }\n}\n\n// Get a property key and transform it in a suitable key for kendo\n// the constraint is that kendo needs a key suitable for javascript object's dot notation\n// i.e a valid js identifier with alphanumeric chars + '_' and '$'\nfunction asKendoPropertyKey(value) {\n  return value.replace(/[^a-zA-z0-9_$]/g, '_');\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/fields.js\n **/"],"sourceRoot":""}